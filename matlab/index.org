#+TITLE: Matlab Computation
:DRAWER:
#+HTML_LINK_HOME: ../index.html
#+HTML_LINK_UP: ../index.html

#+LATEX_CLASS: cleanreport
#+LATEX_CLASS_OPTIONS: [tocnp, secbreak, minted]

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/readtheorg.css"/>
#+HTML_HEAD: <script src="../js/jquery.min.js"></script>
#+HTML_HEAD: <script src="../js/bootstrap.min.js"></script>
#+HTML_HEAD: <script src="../js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script src="../js/readtheorg.js"></script>

#+PROPERTY: header-args:matlab  :session *MATLAB*
#+PROPERTY: header-args:matlab+ :tangle matlab/comp_filters_design.m
#+PROPERTY: header-args:matlab+ :comments org
#+PROPERTY: header-args:matlab+ :exports both
#+PROPERTY: header-args:matlab+ :results none
#+PROPERTY: header-args:matlab+ :eval no-export
#+PROPERTY: header-args:matlab+ :noweb yes
#+PROPERTY: header-args:matlab+ :mkdirp yes
#+PROPERTY: header-args:matlab+ :output-dir figs
:END:

* Introduction                                                        :ignore:

- Section [[sec:system_description]]
- Section [[sec:iff_pure_int]]
- Section [[sec:iff_pseudo_int]]
- Section [[sec:iff_parallel_stiffness]]
- Section [[sec:dvf]]
- Section [[sec:comparison]]

* System Description and Analysis
<<sec:system_description>>

** Introduction                                                      :ignore:
** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** System description
The system consists of one 2 degree of freedom translation stage on top of a spindle (figure [[fig:rotating_xy_platform]]).

#+name: fig:rotating_xy_platform
#+caption: Figure caption
[[file:figs-tikz/rotating_xy_platform.png]]

The control inputs are the forces applied by the actuators of the translation stage ($F_u$ and $F_v$).
As the translation stage is rotating around the Z axis due to the spindle, the forces are applied along $\vec{i}_u$ and $\vec{i}_v$.

The measurement is either the $x-y$ displacement of the object located on top of the translation stage or the $u-v$ displacement of the sample with respect to a fixed reference frame.

** Equations
Based on the Figure [[fig:rotating_xy_platform]].

\begin{equation}
\begin{bmatrix} d_u \\ d_v \end{bmatrix} =
\frac{\frac{1}{k}}{\left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2}
\begin{bmatrix}
  \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} & 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \\
  -2 \frac{\Omega}{\omega_0}\frac{s}{\omega_0}          & \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \\
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

Explain Coriolis and Centrifugal Forces (negative Stiffness)

** Numerical Values
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

We set the additional stiffness and damping to zero (this will be used later).
#+begin_src matlab
  kp = 0; % [N/m]
  cp = 0; % [N/(m/s)]
#+end_src

** Campbell Diagram
The system becomes unstable for $\Omega > \omega_0$.

#+begin_src matlab
  Ws = linspace(0, 2, 51); % Vector of considered rotation speed [rad/s]

  p_ws = zeros(4, length(Ws));

  for W_i = 1:length(Ws)
      W = Ws(W_i);

      polei = pole(1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2));
      [~, i_sort] = sort(imag(polei));
      p_ws(:, W_i) = polei(i_sort);
  end
#+end_src

#+begin_src matlab
  figure;

  ax1 = subplot(1,2,1);
  hold on;
  for p_i = 1:size(p_ws, 1)
      plot(Ws, real(p_ws(p_i, :)), 'k-')
  end
  plot(Ws, zeros(size(Ws)), 'k--')
  hold off;
  xlabel('Rotation Frequency [rad/s]'); ylabel('Pole Real Part');

  ax2 = subplot(1,2,2);
  hold on;
  for p_i = 1:size(p_ws, 1)
      plot(Ws,  imag(p_ws(p_i, :)), 'k-')
      plot(Ws, -imag(p_ws(p_i, :)), 'k-')
  end
  hold off;
  xlabel('Rotation Frequency [rad/s]'); ylabel('Pole Imaginary Part');
#+end_src

** Simscape Model
Define the rotating speed for the Simscape Model.
#+begin_src matlab
  W = 0.1; % Rotation Speed [rad/s]
#+end_src

No controller for now.
#+begin_src matlab
  Kiff = tf(zeros(2));
  Kdvf = tf(zeros(2));
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 3, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  G = linearize(mdl, io, 0);

  %% Input/Output definition
  G.InputName  = {'Fu', 'Fv'};
  G.OutputName = {'du', 'dv'};
#+end_src

** Comparison with the model
#+begin_src matlab
  G_th = (1/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
        [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
         -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)];
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-1, 1, 1000);

  figure;
  ax1 = subplot(2, 2, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G(1,1), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(G_th(1,1), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [m/N]');

  ax3 = subplot(2, 2, 3);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(G(1,1), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(G_th(1,1), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  ax2 = subplot(2, 2, 2);
  hold on;
  plot(freqs, abs(squeeze(freqresp(G(1,2), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(G_th(1,2), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [m/N]');

  ax4 = subplot(2, 2, 4);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(G(1,2), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(G_th(1,2), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2,ax3,ax4],'x');
  xlim([freqs(1), freqs(end)]);

  linkaxes([ax1,ax2],'y');
#+end_src

* Problem with pure Integral Force Feedback
<<sec:iff_pure_int>>

** Introduction                                                      :ignore:

- Diagram with the controller
- Basic idea of IFF

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** Plant Parameters
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

** No parallel stiffness
We set the additional stiffness and damping to zero (this will be used later).
#+begin_src matlab
  kp = 0; % [N/m]
  cp = 0; % [N/(m/s)]
#+end_src

** Equations
The sensed forces are equal to:
\begin{equation}
\begin{bmatrix} f_{u} \\ f_{v} \end{bmatrix} =
\begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix} - (c s + k)
\begin{bmatrix} d_u \\ d_v \end{bmatrix}
\end{equation}

Which then gives:
#+begin_important
\begin{equation}
\begin{bmatrix} f_{u} \\ f_{v} \end{bmatrix} =
\frac{1}{\left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2}
\begin{bmatrix}
  (\frac{s^2}{{\omega_0}^2} - \frac{\Omega^2}{{\omega_0}^2}) (\frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2}) + (2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0})^2 & - (2 \xi \frac{s}{\omega_0} + 1) 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \\
  (2 \xi \frac{s}{\omega_0} + 1) 2 \frac{\Omega}{\omega_0}\frac{s}{\omega_0}          & (\frac{s^2}{{\omega_0}^2} - \frac{\Omega^2}{{\omega_0}^2}) (\frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2}) + (2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0})^2 \\
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}
#+end_important

** Poles and Zeros without damping                                 :noexport:
#+begin_src matlab
  syms W w0 xi positive
  assumealso(w0 > W)
  syms x
#+end_src

#+begin_src matlab
  z = (x^2/w0^2 - W^2/w0^2)*((x^2)/(w0^2) + 1 - (W^2)/(w0^2)) + (2*W*x/(w0^2))^2 == 0
  p = ((x^2)/(w0^2) + 1 - (W^2)/(w0^2))^2 + (2*W*x/(w0^2))^2 == 0
#+end_src

#+begin_src matlab
  solve(p, x)
#+end_src

#+begin_src matlab
  solve(z, x)
#+end_src

The zeros are the roots of:
\begin{equation}
  \left( \frac{s^2}{{\omega_0}^2} - \frac{\Omega^2}{{\omega_0}^2} \right) \left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right) + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2 = 0
\end{equation}

Poles (without damping)
\begin{equation}
  \left(\begin{array}{c} -w_{0}\,1{}\mathrm{i}-\mathrm{W}\,1{}\mathrm{i}\\ -w_{0}\,1{}\mathrm{i}+\mathrm{W}\,1{}\mathrm{i}\\ w_{0}\,1{}\mathrm{i}-\mathrm{W}\,1{}\mathrm{i}\\ w_{0}\,1{}\mathrm{i}+\mathrm{W}\,1{}\mathrm{i} \end{array}\right)
\end{equation}

Zeros (without damping)
\begin{equation}
  \left(\begin{array}{c} -\sqrt{-\frac{w_{0}\,\sqrt{{w_{0}}^2+8\,{\mathrm{W}}^2}}{2}-\frac{{w_{0}}^2}{2}-{\mathrm{W}}^2}\\ -\sqrt{\frac{w_{0}\,\sqrt{{w_{0}}^2+8\,{\mathrm{W}}^2}}{2}-\frac{{w_{0}}^2}{2}-{\mathrm{W}}^2}\\ \sqrt{-\frac{w_{0}\,\sqrt{{w_{0}}^2+8\,{\mathrm{W}}^2}}{2}-\frac{{w_{0}}^2}{2}-{\mathrm{W}}^2}\\ \sqrt{\frac{w_{0}\,\sqrt{{w_{0}}^2+8\,{\mathrm{W}}^2}}{2}-\frac{{w_{0}}^2}{2}-{\mathrm{W}}^2} \end{array}\right)
\end{equation}

** Simscape Model
The rotation speed is set to $\Omega = 0.1 \omega_0$.
#+begin_src matlab
  W = 0.1*w0; % [rad/s]
#+end_src

No controller for now.
#+begin_src matlab
  Kiff = tf(zeros(2));
  Kdvf = tf(zeros(2));
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Giff = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff.InputName  = {'Fu', 'Fv'};
  Giff.OutputName = {'fu', 'fv'};
#+end_src

** Comparison with the model
#+begin_src matlab
  Giff_th = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
            [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
             (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
#+end_src

#+begin_src matlab
  freqs = logspace(-1, 1, 1000);

  figure;
  ax1 = subplot(2, 2, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(Giff_th(1,1), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax3 = subplot(2, 2, 3);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_th(1,1), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  ax2 = subplot(2, 2, 2);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,2), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(Giff_th(1,2), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax4 = subplot(2, 2, 4);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,2), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_th(1,2), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2,ax3,ax4],'x');
  xlim([freqs(1), freqs(end)]);

  linkaxes([ax1,ax2],'y');
#+end_src

** Influence of the rotation speed on the IFF Plant
#+begin_src matlab
  Ws = [0, 0.1, 0.3, 0.8, 1.1]; % Rotating Speeds [rad/s]
#+end_src

#+begin_src matlab
  Gsiff = {zeros(2, 2, length(Ws))};

  for W_i = 1:length(Ws)
      W = Ws(W_i);

      Gsiff(:, :, W_i) = {1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
                        [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
                         (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2]};
  end
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  for W_i = 1:length(Ws)
      plot(freqs, abs(squeeze(freqresp(Gsiff{W_i}(1,1), freqs))), ...
           'DisplayName', sprintf('$\\omega = %.2f \\omega_0 $', Ws(W_i)/w0))
  end
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');
  legend('location', 'northwest');
  ylim([0, 1e3]);

  ax2 = subplot(2, 1, 2);
  hold on;
  for W_i = 1:length(Ws)
      plot(freqs, 180/pi*angle(squeeze(freqresp(Gsiff{W_i}(1,1), freqs))))
  end
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

** Loop Gain
Let's take $\Omega = \frac{\omega_0}{10}$.
#+begin_src matlab
  W = 0.1*w0;
  Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
         [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
          (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];

#+end_src

The decentralized controller contains pure integrators:
\begin{equation}
  \bm{K}_{\text{IFF}}(s) = \frac{g}{s} \begin{bmatrix}
    1 & 0 \\
    0 & 1
  \end{bmatrix}
\end{equation}

#+begin_src matlab
  g = 2;

  Kiff = g/s*tf(eye(2));
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1)*Kiff(1,1), freqs))))
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Loop Gain');

  ax2 = subplot(2, 1, 2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1)*Kiff(1,1), freqs))))
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

** Root Locus
#+begin_src matlab
  Ws = [0, 0.1, 0.3, 0.8, 1.1];
#+end_src

#+begin_src matlab
  Giff = {zeros(2, 2, length(Ws))};

  for W_i = 1:length(Ws)
      W = Ws(W_i);

      Giff(:, :, W_i) = {1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
                        [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
                         (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2]};
  end
#+end_src

#+begin_src matlab :exports none
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  for W_i = 1:length(Ws)
      set(gca,'ColorOrderIndex',W_i);
      plot(real(pole(Giff{W_i})),  imag(pole(Giff{W_i})), 'x', ...
           'DisplayName', sprintf('$\\omega = %.1f \\omega_0 $', Ws(W_i)/w0));
      set(gca,'ColorOrderIndex',W_i);
      plot(real(tzero(Giff{W_i})),  imag(tzero(Giff{W_i})), 'o', ...
           'HandleVisibility', 'off');
      for g = gains
          set(gca,'ColorOrderIndex',W_i);
          cl_poles = pole(feedback(Giff{W_i}, g/s*eye(2)));
          plot(real(cl_poles), imag(cl_poles), '.', ...
               'HandleVisibility', 'off');
      end
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([0, 2.5]);

  xlabel('Real Part'); ylabel('Imaginary Part');
  legend('location', 'northwest');
#+end_src

* Modified IFF (pseudo integrator)
<<sec:iff_pseudo_int>>

** Introduction                                                      :ignore:

- Diagram with the controller
- Basic idea of IFF

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** Plant Parameters
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

** No parallel stiffness
We set the additional stiffness and damping to zero (this will be used later).
#+begin_src matlab
  kp = 0; % [N/m]
  cp = 0; % [N/(m/s)]
#+end_src

** Plant parameters
#+begin_src matlab
  W = 0.1*w0;

  Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
          [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
           (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];

#+end_src

** Control Law
Let's take the integral feedback controller as a low pass filter (pseudo integrator):
\begin{equation}
  K_{\text{IFF}}(s) = g\frac{1}{1 + \frac{s}{\omega_i}} \begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\end{equation}

#+begin_src matlab
  g = 2;
  wi = w0;
#+end_src

#+begin_src matlab
  Kiff = (g/(1+s/wi))*eye(2);
#+end_src

** Loop Gain
#+begin_src matlab
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1)*Kiff(1,1), freqs))))
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax2 = subplot(2, 1, 2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1)*Kiff(1,1), freqs))))
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

** Root Locus
As shown in the Root Locus plot, for some value of the gain, the system is stable.
(The system is however still not conditionally stable).

#+begin_src matlab :exports none
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  plot(real(pole(Giff)),  imag(pole(Giff)), 'kx');
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'ko');
  for g = gains
      clpoles = pole(feedback(Giff, (g/(1+s/wi))*eye(2)));
      plot(real(clpoles), imag(clpoles), 'k.');
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([-1.25, 1.25]);

  xlabel('Real Part'); ylabel('Imaginary Part');
#+end_src

** How does $\omega_i$ influences the attainable damping? Optimal Gain
The DC gain for $G_\text{IFF}$ is (for $\Omega < \omega_0$):
\begin{equation}
  G_{\text{IFF}}(\omega = 0) = \frac{1}{1 - \frac{{\omega_0}^2}{\Omega^2}} \begin{bmatrix}
    1 & 0 \\
    0 & 1
  \end{bmatrix}
\end{equation}

The maximum gain where is system is still stable is
\begin{equation}
  g_\text{max} = \frac{{\omega_0}^2}{\Omega^2} - 1
\end{equation}


Root Locus => Small $\omega_i$ seems to allow more damping but may limit the gain.
#+begin_src matlab
  wis = [0.01, 0.1, 0.5, 1]*w0;
#+end_src

#+begin_src matlab
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  plot(real(pole(Giff)),  imag(pole(Giff)), 'kx');
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'ko');
  for wi_i = 1:length(wis)
      set(gca,'ColorOrderIndex',wi_i);
      wi = wis(wi_i);
      L(wi_i) = plot(nan, nan, '.', 'DisplayName', sprintf('$\\omega_i = %.1e \\omega_0$', wi./w0));
      for g = gains
          clpoles = pole(feedback(Giff, (g/(1+s/wi))*eye(2)));
          set(gca,'ColorOrderIndex',wi_i);
          plot(real(clpoles), imag(clpoles), '.');
      end
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([-1.25, 1.25]);
  legend(L, 'location', 'northwest');
  xlabel('Real Part'); ylabel('Imaginary Part');
 
  clear L
#+end_src

Find wi that yields most damping => there is an optimum.
Limitation of small $\omega_i$: stability/gain margin
Limitation of large $\omega_i$: no damping attainable
#+begin_src matlab
  opt_zeta = zeros(1, length(wis));
  opt_gain = zeros(1, length(wis));

  for wi_i = 1:length(wis)
      gains = linspace(0, w0^2/W^2 - 1, 100);

      for g = gains
          Kiff = (g/(1+s/wis(wi_i)))*eye(2);

          [w, zeta] = damp(minreal(feedback(Giff, Kiff)));

          if min(zeta) > opt_zeta(wi_i) && all(zeta > 0)
              opt_zeta(wi_i) = min(zeta);
              opt_gain(wi_i) = min(gains(g_i));
          end
      end
  end
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  data2orgtable([wis; opt_zeta; opt_gain]', {}, {'wis', 'zeta', 'gain'}, ' %.3f ');
#+end_src

#+RESULTS:
|  wis |  zeta | gain |
|------+-------+------|
| 0.01 | 0.437 | 98.0 |
|  0.1 | 0.829 | 20.0 |
|  0.5 | 0.376 |  3.0 |
|  1.0 | 0.204 |  2.0 |

Root Locus that shows the maximum damping attainable.
#+begin_src matlab
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  plot(real(pole(Giff)),  imag(pole(Giff)), 'kx', 'HandleVisibility', 'off');
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'ko', 'HandleVisibility', 'off');
  for wi_i = 1:length(wis)
      wi = wis(wi_i);
      for g = gains
          clpoles = pole(feedback(Giff, (g/(1+s/wi))*eye(2)));
          set(gca,'ColorOrderIndex',wi_i);
          plot(real(clpoles), imag(clpoles), '.', 'HandleVisibility', 'off');
      end
      clpoles = pole(feedback(Giff, (opt_gain(wi_i)/(1+s/wi))*eye(2)));
      set(gca,'ColorOrderIndex',wi_i);
      plot(real(clpoles), imag(clpoles), 'x', 'DisplayName', sprintf('$\\omega_i = %.2f \\omega_0$', wi./w0));
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([-1.25, 1.25]);
  legend('location', 'northwest');
  xlabel('Real Part'); ylabel('Imaginary Part');
#+end_src

#+begin_src matlab :exports none
  [~, opt_i] = max(opt_zeta);
  Kiff_opt = (opt_gain(opt_i)/(1 + s/wis(opt_i)))*eye(2);
  Giff_cl = feedback(Giff, Kiff_opt);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1), freqs))))
  plot(freqs, abs(squeeze(freqresp(Giff_cl(1,1), freqs))))
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax2 = subplot(2, 1, 2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1), freqs))))
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_cl(1,1), freqs))))
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

* IFF with a stiffness in parallel with the force sensor
<<sec:iff_parallel_stiffness>>

** Introduction                                                      :ignore:

- Diagram with the controller
- Basic idea of IFF

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** Plant Parameters
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

** Schematic

#+name: fig:figure_name
#+caption: Figure caption
[[file:figs-tikz/rotating_xy_platform_springs.png]]

** Physical Explanation
- Negative stiffness induced by gyroscopic effects
- Zeros of the open-loop <=> Poles of the subsystem with the force sensors removes
- As the zeros are the poles of the closed loop system for high gains, we want them to be in the left-half plane
- Thus we want the zeros to be in the left half plant and thus the system with the force sensors stable
- This can be done by adding springs in parallel with the force sensors with a stiffness larger than the virtual negative stiffness added by the gyroscopic effects

The negative stiffness induced by the rotation is:
\begin{equation}
  k_{n} = - m \Omega^2
\end{equation}

And thus, the stiffness in parallel should be such that:
\begin{equation}
  k_{p} > m \Omega^2
\end{equation}

** TODO Equations
The equations should be the same as before by taking $k = k^\prime + k_a$.
I just have to determine the measured force by the sensor

** Effect of the parallel stiffness on the IFF plant
Let's fix the rotating speed:
#+begin_src matlab
  W = 0.1*w0;
#+end_src

And no controller is used.
#+begin_src matlab
  Kiff = tf(zeros(2));
  Kdvf = tf(zeros(2));
#+end_src

And the IFF plant is identified in three different cases:
- without parallel stiffness
- with a small parallel stiffness $k_p < m \Omega^2$
- with a large parallel stiffness $k_p > m \Omega^2$
 
#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  kp = 0;
  cp = 0;

  Giff = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff.InputName  = {'Fu', 'Fv'};
  Giff.OutputName = {'fu', 'fv'};
#+end_src

#+begin_src matlab
  kp = 0.5*m*W^2;
  cp = 0.001;

  Giff_s = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff_s.InputName  = {'Fu', 'Fv'};
  Giff_s.OutputName = {'fu', 'fv'};
#+end_src

#+begin_src matlab
  kp = 1.5*m*W^2;
  cp = 0.001;

  Giff_l = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff_l.InputName  = {'Fu', 'Fv'};
  Giff_l.OutputName = {'fu', 'fv'};
#+end_src

#+begin_src matlab
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1),   freqs))), 'k-')
  plot(freqs, abs(squeeze(freqresp(Giff_s(1,1), freqs))), 'k--')
  plot(freqs, abs(squeeze(freqresp(Giff_l(1,1), freqs))), 'k:')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax2 = subplot(2, 1, 2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1),   freqs))), 'k-', ...
       'DisplayName', '$k_p = 0$')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_s(1,1), freqs))), 'k--', ...
       'DisplayName', '$k_p < m\Omega^2$')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_l(1,1), freqs))), 'k:', ...
       'DisplayName', '$k_p > m\Omega^2$')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;
  legend('location', 'southwest');

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

** Parallel Stiffness effect
Pure IFF controller can be used if:
\begin{equation}
  k_{p} > m \Omega^2
\end{equation}

However, having large values of $k_p$ may:
- decrease the actuator stroke
- decrease the attainable damping (section about optimal value)

** Root locus
#+begin_src matlab :exports none
  figure;

  gains = logspace(-2, 2, 100);

  hold on;
  set(gca,'ColorOrderIndex',1);
  plot(real(pole(Giff)),  imag(pole(Giff)), 'x', ...
       'DisplayName', '$k_p < m\Omega^2$');
  set(gca,'ColorOrderIndex',1);
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      cl_poles = pole(feedback(Giff, (g/s)*eye(2)));
      set(gca,'ColorOrderIndex',1);
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end

  set(gca,'ColorOrderIndex',2);
  plot(real(pole(Giff_s)),  imag(pole(Giff_s)), 'x', ...
       'DisplayName', '$k_p < m\Omega^2$');
  set(gca,'ColorOrderIndex',2);
  plot(real(tzero(Giff_s)),  imag(tzero(Giff_s)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      cl_poles = pole(feedback(Giff_s, (g/s)*eye(2)));
      set(gca,'ColorOrderIndex',2);
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end

  set(gca,'ColorOrderIndex',3);
  plot(real(pole(Giff_l)),  imag(pole(Giff_l)), 'x', ...
       'DisplayName', '$k_p > m\Omega^2$');
  set(gca,'ColorOrderIndex',3);
  plot(real(tzero(Giff_l)),  imag(tzero(Giff_l)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      set(gca,'ColorOrderIndex',3);
      cl_poles = pole(feedback(Giff_l, (g/s)*eye(2)));
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end
  hold off;
  axis square;
  xlim([-1, 0.2]); ylim([0, 1.2]);

  xlabel('Real Part'); ylabel('Imaginary Part');
  legend('location', 'northwest');
#+end_src

** Optimal value of $k_p$
#+begin_src matlab
  kps = [0, 0.5, 1, 2, 10]*m*W^2;
  cp = 0.01;
#+end_src

#+begin_src matlab :exports none
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  for kp_i = 1:length(kps)
      kp = kps(kp_i);
      Giff = linearize(mdl, io, 0);

      set(gca,'ColorOrderIndex',kp_i);
      plot(real(pole(Giff)),  imag(pole(Giff)), 'x', ...
           'DisplayName', sprintf('$k_p = %.1f m \\Omega^2$', kp/(m*W^2)));
      set(gca,'ColorOrderIndex',kp_i);
      plot(real(tzero(Giff)),  imag(tzero(Giff)), 'o', ...
           'HandleVisibility', 'off');
      for g = gains
          Kiffa = (g/s)*eye(2);
          cl_poles = pole(feedback(Giff, Kiffa));
          set(gca,'ColorOrderIndex',kp_i);
          plot(real(cl_poles), imag(cl_poles), '.', ...
               'HandleVisibility', 'off');
      end
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([0, 2.5]);

  xlabel('Real Part'); ylabel('Imaginary Part');
  legend('location', 'northwest');
#+end_src

To have unconditional stability:
\begin{equation}
  k_{p} > m \Omega^2
\end{equation}

But if $k_p$ is too late, the attainable damping is decreasing and this may as well limit the actuator stroke/force.

** Optimal Gain
Let's take $k_p = 2 m \Omega^2$ and find the optimal IFF control gain.

#+begin_src matlab
  kp = 2*m*W;
  cp = 0.01;
 
  Giff = linearize(mdl, io, 0);
#+end_src

#+begin_src matlab
  opt_zeta = 0;
  opt_gain = 0;

  gains = logspace(-2, 4, 100);

  for g = gains
      Kiff = (g/s)*eye(2);

      [w, zeta] = damp(minreal(feedback(Giff, Kiff)));

      if min(zeta) > opt_zeta && all(zeta > 0)
          opt_zeta = min(zeta);
          opt_gain = min(gains(g_i));
      end
  end
#+end_src

#+begin_src matlab
  figure;

  gains = logspace(-2, 4, 100);

  hold on;
  plot(real(pole(Giff)),  imag(pole(Giff)), 'kx', 'HandleVisibility', 'off');
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'ko', 'HandleVisibility', 'off');
  for g = gains
      clpoles = pole(feedback(Giff, (g/s)*eye(2)));
      plot(real(clpoles), imag(clpoles), 'k.', 'HandleVisibility', 'off');
  end
  % Optimal Gain
  clpoles = pole(feedback(Giff, (opt_gain/s)*eye(2)));
  set(gca,'ColorOrderIndex',1);
  plot(real(clpoles), imag(clpoles), 'x', 'HandleVisibility', 'off');
  hold off;
  axis square;
  xlim([-1.2, 0.05]); ylim([0, 1.25]);
  xlabel('Real Part'); ylabel('Imaginary Part');
#+end_src

#+begin_src matlab :exports none
  Kiff_opt = (opt_gain(opt_i)/s)*eye(2);
  Giff_cl = feedback(Giff, Kiff_opt);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 1, 1000);

  figure;

  ax1 = subplot(2, 1, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Giff(1,1), freqs))))
  plot(freqs, abs(squeeze(freqresp(Giff_cl(1,1), freqs))))
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [N/N]');

  ax2 = subplot(2, 1, 2);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff(1,1), freqs))))
  plot(freqs, 180/pi*angle(squeeze(freqresp(Giff_cl(1,1), freqs))))
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

* Direct Velocity Feedback
<<sec:dvf>>

** Introduction                                                      :ignore:
** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** Equations
The sensed relative velocity are equal to:
#+begin_important
\begin{equation}
\begin{bmatrix} \dot{d}_u \\ \dot{d}_v \end{bmatrix} =
\frac{s \frac{1}{k}}{\left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2}
\begin{bmatrix}
  \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} & 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \\
  -2 \frac{\Omega}{\omega_0}\frac{s}{\omega_0}          & \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \\
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}
#+end_important

** Plant Parameters
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

** Plant - Bode Plot
The controllers are set to zero.
#+begin_src matlab
  Kiff = tf(zeros(2));
  Kdvf = tf(zeros(2));
#+end_src

No parallel stiffness and damper is used.
#+begin_src matlab
  kp = 0; % [N/m]
  cp = 0; % [N/(m/s)]
#+end_src

The rotating speed is set to $\Omega = 0.1 \omega_0$.
#+begin_src matlab
  W = 0.1*w0;
#+end_src

The DVF plant is identified from the Simscape model and compared with the analytical one.

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 1, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Gdvf = linearize(mdl, io, 0);

  %% Input/Output definition
  Gdvf.InputName  = {'Fu', 'Fv'};
  Gdvf.OutputName = {'Vu', 'Vv'};
#+end_src

#+begin_src matlab
  Gdvf_th = (s/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
            [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
             -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)];
#+end_src

#+begin_src matlab
  freqs = logspace(-1, 1, 1000);

  figure;
  ax1 = subplot(2, 2, 1);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Gdvf(1,1), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(Gdvf_th(1,1), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [m/s/N]');

  ax3 = subplot(2, 2, 3);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gdvf(1,1), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gdvf_th(1,1), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  ax2 = subplot(2, 2, 2);
  hold on;
  plot(freqs, abs(squeeze(freqresp(Gdvf(1,2), freqs))), '-')
  plot(freqs, abs(squeeze(freqresp(Gdvf_th(1,2), freqs))), '--')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]); ylabel('Amplitude [m/s/N]');

  ax4 = subplot(2, 2, 4);
  hold on;
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gdvf(1,2), freqs))), '-')
  plot(freqs, 180/pi*angle(squeeze(freqresp(Gdvf_th(1,2), freqs))), '--')
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'lin');
  xlabel('Frequency [rad/s]'); ylabel('Phase [deg]');
  yticks(-180:90:180);
  ylim([-180 180]);
  hold off;

  linkaxes([ax1,ax2,ax3,ax4],'x');
  xlim([freqs(1), freqs(end)]);

  linkaxes([ax1,ax2],'y');
#+end_src

** Root Locus
The controller is a pure gain::
\begin{equation}
  K_{\text{DVF}}(s) = g
\end{equation}

#+begin_src matlab
  Ws = [0, 0.1, 0.3, 0.8, 1.1];
#+end_src

#+begin_src matlab
  gains = logspace(-2, 1, 100);

  figure;
  hold on;
  for W_i = 1:length(Ws)
      W = Ws(W_i);

      Gdvf = (s/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
             [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
              -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)];

      set(gca,'ColorOrderIndex',W_i);
      plot(real(pole(Gdvf)),  imag(pole(Gdvf)), 'x', ...
           'DisplayName', sprintf('$\\omega = %.2f \\omega_0 $', W/w0));

      set(gca,'ColorOrderIndex',W_i);
      plot(real(tzero(Gdvf)),  imag(tzero(Gdvf)), 'o', ...
           'HandleVisibility', 'off');
   
      for g = gains
          set(gca,'ColorOrderIndex',W_i);
          cl_poles = pole(feedback(Gdvf, g*eye(2)));

          plot(real(cl_poles), imag(cl_poles), '.', ...
               'HandleVisibility', 'off');
      end
  end
  hold off;
  axis square;
  xlim([-2, 0.5]); ylim([0, 2.5]);

  xlabel('Real Part'); ylabel('Imaginary Part');
  legend('location', 'northwest');
#+end_src

* Comparison
<<sec:comparison>>

** Introduction                                                      :ignore:
** Matlab Init                                             :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  addpath('./matlab/');
#+end_src

#+begin_src matlab
  open('rotating_frame.slx');
#+end_src

** Plant Parameters
Let's define initial values for the model.
#+begin_src matlab
  k = 1; % [N/m]
  m = 1; % [kg]
  c = 0.05; % [N/(m/s)]

  xi = c/(2*sqrt(k*m));
  w0 = sqrt(k/m); % [rad/s]
#+end_src

The rotation speed is set to $\Omega = 0.1 \omega_0$.
#+begin_src matlab
  W = 0.1*w0; % [rad/s]
#+end_src

#+begin_src matlab
  Kiff = tf(zeros(2));
  Kdvf = tf(zeros(2));
#+end_src

** Root Locus
*** Pseudo Integrator IFF
#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Giff = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff.InputName  = {'Fu', 'Fv'};
  Giff.OutputName = {'Fmu', 'Fmv'};
#+end_src

*** IFF With parallel Stiffness
#+begin_src matlab
  kp = 2*m*W^2;
  cp = 0.01;
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Giff_kp = linearize(mdl, io, 0);

  %% Input/Output definition
  Giff_kp.InputName  = {'Fu', 'Fv'};
  Giff_kp.OutputName = {'Fmu', 'Fmv'};
#+end_src

*** DVF
#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/G'], 1, 'openoutput'); io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Gdvf = linearize(mdl, io, 0);

  %% Input/Output definition
  Gdvf.InputName  = {'Fu', 'Fv'};
  Gdvf.OutputName = {'Vu', 'Vv'};
#+end_src

*** Root Locus
#+begin_src matlab
  wi = 0.1*w0;
#+end_src

#+begin_src matlab :exports none
  figure;

  gains = logspace(-2, 2, 100);

  hold on;
  set(gca,'ColorOrderIndex',1);
  plot(real(pole(Giff)),  imag(pole(Giff)), 'x', ...
       'DisplayName', 'Pseudo Integrator');
  set(gca,'ColorOrderIndex',1);
  plot(real(tzero(Giff)),  imag(tzero(Giff)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      Kiff = (g/(1 + s/wi))*eye(2);
      cl_poles = pole(feedback(Giff, Kiff));
      set(gca,'ColorOrderIndex',1);
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end

  set(gca,'ColorOrderIndex',2);
  plot(real(pole(Giff_kp)),  imag(pole(Giff_kp)), 'x', ...
       'DisplayName', 'Parallel Stiffness');
  set(gca,'ColorOrderIndex',2);
  plot(real(tzero(Giff_kp)),  imag(tzero(Giff_kp)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      Kiffa = (g/s)*eye(2);
      cl_poles = pole(feedback(Giff_kp, Kiffa));
      set(gca,'ColorOrderIndex',2);
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end

  set(gca,'ColorOrderIndex',3);
  plot(real(pole(Gdvf)),  imag(pole(Gdvf)), 'x', ...
       'DisplayName', 'DVF');
  set(gca,'ColorOrderIndex',3);
  plot(real(tzero(Gdvf)),  imag(tzero(Gdvf)), 'o', ...
       'HandleVisibility', 'off');
  for g = gains
      Kdvf = g*eye(2);
      cl_poles = pole(feedback(Gdvf, Kdvf));
      set(gca,'ColorOrderIndex',3);
      plot(real(cl_poles), imag(cl_poles), '.', ...
           'HandleVisibility', 'off');
  end
  hold off;
  axis square;
  xlim([-1.2, 0.05]); ylim([0, 1.25]);

  xlabel('Real Part'); ylabel('Imaginary Part');
  legend('location', 'northwest');
#+end_src

** Controllers - Optimal Gains
Estimate the controller gain that yields good damping in all cases.

Pseudo integrator IFF:
#+begin_src matlab :exports none
  gains = logspace(-2, 4, 100);
  opt_zeta_iff = 0;
  opt_gain_iff = 0;

  for g = gains
      Kiff = (g/(1+s/wi))*eye(2);

      [w, zeta] = damp(minreal(feedback(Giff, Kiff)));

      if min(zeta) > opt_zeta_iff && all(zeta > 0)
        opt_zeta_iff = min(zeta);
        opt_gain_iff = min(gains(g_i));
      end
  end
#+end_src

Parallel Stiffness
#+begin_src matlab :exports none
  gains = logspace(-2, 4, 100);
  opt_zeta_kp = 0;
  opt_gain_kp = 0;

  for g = gains
      Kiff = g/s*eye(2);

      [w, zeta] = damp(minreal(feedback(Giff_kp, Kiff)));

      if min(zeta) > opt_zeta_kp && all(zeta > 0)
        opt_zeta_kp = min(zeta);
        opt_gain_kp = min(gains(g_i));
      end
  end
#+end_src

DVF:
#+begin_src matlab :exports none
  gains = logspace(0, 4, 100);
  opt_zeta_dvf = 0;
  opt_gain_dvf = 0;

  for g = gains
      Kdvf = g*eye(2);

      [w, zeta] = damp(minreal(feedback(Gdvf, Kdvf)));

      if min(zeta) > opt_zeta_dvf && all(zeta > 0) && min(zeta) < 0.85
        opt_zeta_dvf = min(zeta);
        opt_gain_dvf = min(gains(g_i));
      end
  end
#+end_src

#+begin_src matlab
  opt_zeta_iff, opt_zeta_kp, opt_zeta_dvf
#+end_src

** Transmissibility
*** Open Loop
#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = tf(zeros(2));
#+end_src

#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Tol = linearize(mdl, io, 0);

  %% Input/Output definition
  Tol.InputName  = {'Dwx', 'Dwy'};
  Tol.OutputName = {'Dx', 'Dy'};
#+end_src

*** Pseudo Integrator IFF
#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = opt_gain_iff/(1 + s/wi)*tf(eye(2));
#+end_src

#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Tiff = linearize(mdl, io, 0);

  %% Input/Output definition
  Tiff.InputName  = {'Dwx', 'Dwy'};
  Tiff.OutputName = {'Dx', 'Dy'};
#+end_src

*** IFF With parallel Stiffness
#+begin_src matlab
  kp = 2*m*W^2;
  cp = 0.01;
#+end_src

#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = opt_gain_kp/s*tf(eye(2));
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Tiff_kp = linearize(mdl, io, 0);

  %% Input/Output definition
  Tiff_kp.InputName  = {'Dwx', 'Dwy'};
  Tiff_kp.OutputName = {'Dx', 'Dy'};
#+end_src

*** DVF
#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  Kdvf = opt_gain_kp*tf(eye(2));
  Kiff = tf(zeros(2));
#+end_src

#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Tdvf = linearize(mdl, io, 0);

  %% Input/Output definition
  Tdvf.InputName  = {'Dwx', 'Dwy'};
  Tdvf.OutputName = {'Dx', 'Dy'};
#+end_src

*** Transmissibility
#+begin_src matlab
  freqs = logspace(-2, 1, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(Tiff(1,1), freqs))), ...
       'DisplayName', 'IFF Pseudo int')
  plot(freqs, abs(squeeze(freqresp(Tiff_kp(1,1), freqs))), ...
       'DisplayName', 'IFF Paral. stiff')
  plot(freqs, abs(squeeze(freqresp(Tdvf(1,1), freqs))), ...
       'DisplayName', 'DVF')
  plot(freqs, abs(squeeze(freqresp(Tol(1,1), freqs))), 'k-', ...
       'DisplayName', 'IFF Pseudo int')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Frequency [rad/s]'); ylabel('Amplitude [m/m]');
  legend('location', 'northwest');
#+end_src

** Compliance
*** Open Loop
#+begin_src matlab
  %% Name of the Simulink File
  mdl = 'rotating_frame';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/fd'], 1, 'input');  io_i = io_i + 1;
  io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
#+end_src

#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = tf(zeros(2));
#+end_src

#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  Col = linearize(mdl, io, 0);

  %% Input/Output definition
  Col.InputName  = {'Fdx', 'Fdy'};
  Col.OutputName = {'Dx', 'Dy'};
#+end_src

*** Pseudo Integrator IFF
#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = opt_gain_iff/(1 + s/wi)*tf(eye(2));
#+end_src

#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  Ciff = linearize(mdl, io, 0);

  %% Input/Output definition
  Ciff.InputName  = {'Fdx', 'Fdy'};
  Ciff.OutputName = {'Dx', 'Dy'};
#+end_src

*** IFF With parallel Stiffness
#+begin_src matlab
  kp = 2*m*W^2;
  cp = 0.01;
#+end_src

#+begin_src matlab
  Kdvf = tf(zeros(2));
  Kiff = opt_gain_kp/s*tf(eye(2));
#+end_src

#+begin_src matlab
  Ciff_kp = linearize(mdl, io, 0);

  %% Input/Output definition
  Ciff_kp.InputName  = {'Fdx', 'Fdy'};
  Ciff_kp.OutputName = {'Dx', 'Dy'};
#+end_src

*** DVF
#+begin_src matlab
  kp = 0;
  cp = 0;
#+end_src

#+begin_src matlab
  Kdvf = opt_gain_kp*tf(eye(2));
  Kiff = tf(zeros(2));
#+end_src

#+begin_src matlab
  Cdvf = linearize(mdl, io, 0);

  %% Input/Output definition
  Cdvf.InputName  = {'Fdx', 'Fdy'};
  Cdvf.OutputName = {'Dx', 'Dy'};
#+end_src

*** Compliance
#+begin_src matlab
  freqs = logspace(-2, 1, 1000);

  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(Ciff(1,1), freqs))), ...
       'DisplayName', 'IFF Pseudo int')
  plot(freqs, abs(squeeze(freqresp(Ciff_kp(1,1), freqs))), ...
       'DisplayName', 'IFF Paral. stiff')
  plot(freqs, abs(squeeze(freqresp(Cdvf(1,1), freqs))), ...
       'DisplayName', 'DVF')
  plot(freqs, abs(squeeze(freqresp(Col(1,1), freqs))), 'k-', ...
       'DisplayName', 'IFF Pseudo int')
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Frequency [rad/s]'); ylabel('Compliance [m/N]');
  legend('location', 'northwest');
#+end_src

* Notations
<<sec:notations>>

|                                   | Mathematical Notation        | Matlab        | Unit    |
|-----------------------------------+------------------------------+---------------+---------|
| Actuator Stiffness                | $k$                          | =k=           | N/m     |
| Actuator Damping                  | $c$                          | =c=           | N/(m/s) |
| Payload Mass                      | $m$                          | =m=           | kg      |
| Damping Ratio                     | $\xi = \frac{c}{2\sqrt{km}}$ | =xi=          |         |
| Actuator Force                    | $\bm{F}, F_u, F_v$           | =F= =Fu= =Fv= | N       |
| Force Sensor signal               | $\bm{f}, f_u, f_v$           | =f= =fu= =fv= | N       |
| Relative Displacement             | $\bm{d}, d_u, d_v$           | =d= =du= =dv= | m       |
| Relative Velocity                 | $\bm{v}, v_u, v_v$           | =v= =vu= =vv= | m/s     |
| Resonance freq. when $\Omega = 0$ | $\omega_0$                   | =w0=          | rad/s   |
| Rotation Speed                    | $\Omega = \dot{\theta}$      | =W=           | rad/s   |

|                  | Mathematical Notation | Matlab | Unit    |
|------------------+-----------------------+--------+---------|
| Laplace variable | $s$                   | =s=    |         |
| Complex number   | $j$                   | =j=    |         |
| Frequency        | $\omega$              | =w=    | [rad/s] |

|                | Mathematical Notation                          | Matlab | Unit    |
|----------------+------------------------------------------------+--------+---------|
| IFF Plant      | $\bm{G}_\text{IFF}(s) = \frac{\bm{f}}{\bm{F}}$ | =Giff= | N/N     |
| DVF Plant      | $\bm{G}_\text{DVF}(s) = \frac{\bm{v}}{\bm{F}}$ | =Gdvf= | (m/s)/N |
| IFF Controller | $\bm{K}_\text{IFF}(s)$                         | =Kiff= |         |
| DVF Controller | $\bm{K}_\text{DVF}(s)$                         | =Kdvf= |         |
