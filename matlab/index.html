<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-18 jeu. 11:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Matlab Computation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Thomas Dehaeze" />
<link rel="stylesheet" type="text/css" href="../css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../css/readtheorg.css"/>
<script src="../js/jquery.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script src="../js/jquery.stickytableheaders.min.js"></script>
<script src="../js/readtheorg.js"></script>
<script>MathJax = {
          tex: {
            tags: 'ams',
            macros: {bm: ["\\boldsymbol{#1}",1],}
            }
          };
          </script>
          <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Matlab Computation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7fd3887">1. System Description and Analysis</a>
<ul>
<li><a href="#org67d1283">1.1. System description</a></li>
<li><a href="#orgd899328">1.2. Equations</a></li>
<li><a href="#org3653395">1.3. Numerical Values</a></li>
<li><a href="#org0e5941a">1.4. Campbell Diagram</a></li>
<li><a href="#orgba91176">1.5. Simscape Model</a></li>
<li><a href="#orgb6b21fc">1.6. Comparison of the Analytical Model and the Simscape Model</a></li>
<li><a href="#orgbda2c32">1.7. Effect of the rotation speed</a></li>
</ul>
</li>
<li><a href="#org502cb17">2. Problem with pure Integral Force Feedback</a>
<ul>
<li><a href="#org5213c05">2.1. Plant Parameters</a></li>
<li><a href="#org2dd3e37">2.2. Equations</a></li>
<li><a href="#orgdec4977">2.3. Simscape Model</a></li>
<li><a href="#org18b58bb">2.4. Comparison of the Analytical Model and the Simscape Model</a></li>
<li><a href="#org06b805f">2.5. Effect of the rotation speed</a></li>
<li><a href="#orge63f126">2.6. Decentralized Integral Force Feedback</a></li>
<li><a href="#orgcdc9bd6">2.7. Sort poles</a></li>
</ul>
</li>
<li><a href="#org18df7e1">3. Modified IFF (pseudo integrator)</a>
<ul>
<li><a href="#orgae8a5d7">3.1. Plant Parameters</a></li>
<li><a href="#org6abeea4">3.2. Modified Integral Force Feedback Controller</a></li>
<li><a href="#org947c64b">3.3. Root Locus</a></li>
<li><a href="#org98a17cf">3.4. What is the optimal \(\omega_i\) and \(g\)?</a></li>
</ul>
</li>
<li><a href="#orga94cade">4. IFF with a stiffness in parallel with the force sensor</a>
<ul>
<li><a href="#org540ef74">4.1. Equations</a></li>
<li><a href="#org108335f">4.2. Plant Parameters</a></li>
<li><a href="#org32f7060">4.3. Schematic</a></li>
<li><a href="#orged2bad9">4.4. Physical Explanation</a></li>
<li><a href="#org17ff45b">4.5. Effect of the parallel stiffness on the IFF plant</a></li>
<li><a href="#orgc2b6bef">4.6. IFF when adding a spring in parallel</a></li>
<li><a href="#orga5a387a">4.7. Effect of \(k_p\) on the attainable damping</a></li>
<li><a href="#org2d75241">4.8. Optimal Gain</a></li>
</ul>
</li>
<li><a href="#orgcdcde0b">5. Direct Velocity Feedback</a>
<ul>
<li><a href="#org720c634">5.1. Equations</a></li>
<li><a href="#orgf603713">5.2. Plant Parameters</a></li>
<li><a href="#org8301d5f">5.3. Plant - Bode Plot</a></li>
<li><a href="#org9e4d88f">5.4. Comparison of the Analytical Model and the Simscape Model</a></li>
<li><a href="#orga076c03">5.5. Root Locus</a>
<ul>
<li>
<ul>
<li><a href="#orgaeec22e">5.5.0.1. Root Locus Plots</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4e87780">6. Comparison</a>
<ul>
<li><a href="#org6d1e549">6.1. Plant Parameters</a></li>
<li><a href="#orgb2d5912">6.2. Root Locus</a></li>
<li><a href="#org96ec842">6.3. Controllers - Optimal Gains</a></li>
<li><a href="#org456f89e">6.4. Transmissibility</a></li>
<li><a href="#org9ae98b1">6.5. Compliance</a></li>
</ul>
</li>
<li><a href="#orgd03ac7f">7. Notations</a></li>
<li><a href="#orgdc36b6b">8. Function</a>
<ul>
<li><a href="#org1b97ee6">8.1. Sort Poles for the Root Locus</a>
<ul>
<li><a href="#orgd432ea5">Function description</a></li>
<li><a href="#org81644c0">Optional Parameters</a></li>
<li><a href="#orgf223cdb">Function</a></li>
<li><a href="#orga51595e">Remove useless poles</a></li>
<li><a href="#org496fb30">Sort poles</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<ul class="org-ul">
<li>Section <a href="#org3251429">1</a></li>
<li>Section <a href="#org7d73627">2</a></li>
<li>Section <a href="#orgf47e330">3</a></li>
<li>Section <a href="#org7314486">4</a></li>
<li>Section <a href="#org99ddc3d">5</a></li>
<li>Section <a href="#org2e13fe1">6</a></li>
<li>Section <a href="#orgead2db3">7</a></li>
</ul>

<div id="outline-container-org7fd3887" class="outline-2">
<h2 id="org7fd3887"><span class="section-number-2">1</span> System Description and Analysis</h2>
<div class="outline-text-2" id="text-1">
<p>
<a id="org3251429"></a>
</p>
</div>

<div id="outline-container-org67d1283" class="outline-3">
<h3 id="org67d1283"><span class="section-number-3">1.1</span> System description</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The system consists of one 2 degree of freedom translation stage on top of a spindle (figure <a href="#org9616080">1</a>).
</p>


<div id="org9616080" class="figure">
<p><img src="figs-tikz/rotating_xy_platform.png" alt="rotating_xy_platform.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Schematic of the studied system</p>
</div>

<p>
The control inputs are the forces applied by the actuators of the translation stage (\(F_u\) and \(F_v\)).
As the translation stage is rotating around the Z axis due to the spindle, the forces are applied along \(\vec{i}_u\) and \(\vec{i}_v\).
</p>

<p>
The measurement is either the \(x-y\) displacement of the object located on top of the translation stage or the \(u-v\) displacement of the sample with respect to a fixed reference frame.
</p>
</div>
</div>

<div id="outline-container-orgd899328" class="outline-3">
<h3 id="orgd899328"><span class="section-number-3">1.2</span> Equations</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Based on the Figure <a href="#org9616080">1</a>, the equations of motions are:
</p>
<div class="important">
\begin{equation}
\begin{bmatrix} d_u \\ d_v \end{bmatrix} =
\bm{G}_d
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

\begin{equation}
\begin{bmatrix} d_u \\ d_v \end{bmatrix} =
\frac{1}{k} \frac{1}{G_{dp}}
\begin{bmatrix}
   G_{dz} & G_{dc} \\
  -G_{dc} & G_{dz}
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}
<p>
With:
</p>
\begin{align}
  G_{dp} &= \left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2 \\
  G_{dz} &= \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \\
  G_{dc} &= 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0}
\end{align}

</div>

<p>
Explain Coriolis and Centrifugal Forces (negative Stiffness)
=&gt; First write the equations in terms of \(k\), \(m\) and \(c\) and explain the terms.
</p>
</div>
</div>

<div id="outline-container-org3653395" class="outline-3">
<h3 id="org3653395"><span class="section-number-3">1.3</span> Numerical Values</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>
</div>
</div>

<div id="outline-container-org0e5941a" class="outline-3">
<h3 id="org0e5941a"><span class="section-number-3">1.4</span> Campbell Diagram</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The Campbell Diagram displays the evolution of the real and imaginary parts of the system as a function of the rotating speed.
</p>

<p>
It is shown in Figure <a href="#org7159e29">2</a>, and one can see that the system becomes unstable for \(\Omega > \omega_0\) (the real part of one of the poles becomes positive).
</p>


<div id="org7159e29" class="figure">
<p><img src="figs/campbell_diagram.png" alt="campbell_diagram.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Campbell Diagram</p>
</div>
</div>
</div>

<div id="outline-container-orgba91176" class="outline-3">
<h3 id="orgba91176"><span class="section-number-3">1.5</span> Simscape Model</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Define the rotating speed for the Simscape Model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1; % Rotation Speed [rad/s]
</pre>
</div>

<p>
The transfer function from \([F_u, F_v]\) to \([d_u, d_v]\) is identified from the Simscape model.
</p>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 3, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">G = linearize(mdl, io, 0);

%% Input/Output definition
G.InputName  = {'Fu', 'Fv'};
G.OutputName = {'du', 'dv'};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb6b21fc" class="outline-3">
<h3 id="orgb6b21fc"><span class="section-number-3">1.6</span> Comparison of the Analytical Model and the Simscape Model</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The same transfer function from \([F_u, F_v]\) to \([d_u, d_v]\) is written down from the analytical model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Gth = (1/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
      [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
       -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)];
</pre>
</div>

<p>
Both transfer functions are compared in Figure <a href="#org489a80b">3</a> and are found to perfectly match.
</p>


<div id="org489a80b" class="figure">
<p><img src="figs/plant_simscape_analytical.png" alt="plant_simscape_analytical.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Bode plot of the transfer function from \([F_u, F_v]\) to \([d_u, d_v]\) as identified from the Simscape model and from an analytical model</p>
</div>
</div>
</div>

<div id="outline-container-orgbda2c32" class="outline-3">
<h3 id="orgbda2c32"><span class="section-number-3">1.7</span> Effect of the rotation speed</h3>
<div class="outline-text-3" id="text-1-7">
<p>
The transfer functions from \([F_u, F_v]\) to \([d_u, d_v]\) are identified for the following rotating speeds.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Ws = [0, 0.1, 0.5, 0.8, 1.1]*w0; % [rad/s]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Gs = {zeros(2, 2, length(Ws))};

for W_i = 1:length(Ws)
    W = Ws(W_i);

    Gs(:, :, W_i) = {(1/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
                     [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
                      -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)]};
end
</pre>
</div>

<p>
They are compared in Figure <a href="#org0d285ce">4</a>.
</p>


<div id="org0d285ce" class="figure">
<p><img src="figs/plant_compare_rotating_speed.png" alt="plant_compare_rotating_speed.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Comparison of the transfer functions from \([F_u, F_v]\) to \([d_u, d_v]\) for several rotating speed</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org502cb17" class="outline-2">
<h2 id="org502cb17"><span class="section-number-2">2</span> Problem with pure Integral Force Feedback</h2>
<div class="outline-text-2" id="text-2">
<p>
<a id="org7d73627"></a>
</p>
<ul class="org-ul">
<li>Diagram with the controller</li>
<li>Basic idea of IFF</li>
</ul>
</div>

<div id="outline-container-org5213c05" class="outline-3">
<h3 id="org5213c05"><span class="section-number-3">2.1</span> Plant Parameters</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>
</div>
</div>

<div id="outline-container-org2dd3e37" class="outline-3">
<h3 id="org2dd3e37"><span class="section-number-3">2.2</span> Equations</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The sensed forces are equal to:
</p>
\begin{equation}
\begin{bmatrix} f_{u} \\ f_{v} \end{bmatrix} =
\begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix} - (c s + k)
\begin{bmatrix} d_u \\ d_v \end{bmatrix}
\end{equation}

<p>
Which then gives:
</p>
<div class="important">
\begin{equation}
\begin{bmatrix} f_{u} \\ f_{v} \end{bmatrix} =
\bm{G}_{f}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

\begin{equation}
\begin{bmatrix} f_{u} \\ f_{v} \end{bmatrix} =
\frac{1}{G_{fp}}
\begin{bmatrix}
  G_{fz} & -G_{fc} \\
  G_{fc} &  G_{fz}
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

\begin{align}
  G_{fp} &= \left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2 \\
  G_{fz} &= \left( \frac{s^2}{{\omega_0}^2} - \frac{\Omega^2}{{\omega_0}^2} \right) \left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right) + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2 \\
  G_{fc} &= \left( 2 \xi \frac{s}{\omega_0} + 1 \right) \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)
\end{align}

</div>
</div>
</div>

<div id="outline-container-orgdec4977" class="outline-3">
<h3 id="orgdec4977"><span class="section-number-3">2.3</span> Simscape Model</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The rotation speed is set to \(\Omega = 0.1 \omega_0\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1*w0; % [rad/s]
</pre>
</div>

<p>
And the transfer function from \([F_u, F_v]\) to \([f_u, f_v]\) is identified using the Simscape model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Giff = linearize(mdl, io, 0);

%% Input/Output definition
Giff.InputName  = {'Fu', 'Fv'};
Giff.OutputName = {'fu', 'fv'};
</pre>
</div>
</div>
</div>

<div id="outline-container-org18b58bb" class="outline-3">
<h3 id="org18b58bb"><span class="section-number-3">2.4</span> Comparison of the Analytical Model and the Simscape Model</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The same transfer function from \([F_u, F_v]\) to \([f_u, f_v]\) is written down from the analytical model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Giff_th = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
          [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
           (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
</pre>
</div>

<p>
The two are compared in Figure <a href="#org874c82b">5</a> and found to perfectly match.
</p>


<div id="org874c82b" class="figure">
<p><img src="figs/plant_iff_comp_simscape_analytical.png" alt="plant_iff_comp_simscape_analytical.png" />
</p>
<p><span class="figure-number">Figure 5: </span>Comparison of the transfer functions from \([F_u, F_v]\) to \([f_u, f_v]\) between the Simscape model and the analytical one</p>
</div>
</div>
</div>

<div id="outline-container-org06b805f" class="outline-3">
<h3 id="org06b805f"><span class="section-number-3">2.5</span> Effect of the rotation speed</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The transfer functions from \([F_u, F_v]\) to \([f_u, f_v]\) are identified for the following rotating speeds.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Ws = [0, 0.1, 0.5, 0.8, 1.1]*w0; % Rotating Speeds [rad/s]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Gsiff = {zeros(2, 2, length(Ws))};

for W_i = 1:length(Ws)
    W = Ws(W_i);

    Gsiff(:, :, W_i) = {1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
                      [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
                       (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2]};
end
</pre>
</div>

<p>
The obtained transfer functions are shown in Figure <a href="#org5b507fd">6</a>.
</p>

<div id="org5b507fd" class="figure">
<p><img src="figs/plant_iff_compare_rotating_speed.png" alt="plant_iff_compare_rotating_speed.png" />
</p>
<p><span class="figure-number">Figure 6: </span>Comparison of the transfer functions from \([F_u, F_v]\) to \([f_u, f_v]\) for several rotating speed</p>
</div>
</div>
</div>

<div id="outline-container-orge63f126" class="outline-3">
<h3 id="orge63f126"><span class="section-number-3">2.6</span> Decentralized Integral Force Feedback</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Let&rsquo;s take \(\Omega = \frac{\omega_0}{10}\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = w0/10;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
       [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
        (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
</pre>
</div>

<p>
The decentralized IFF controller consists of pure integrators:
</p>
\begin{equation}
  \bm{K}_{\text{IFF}}(s) = \frac{g}{s} \begin{bmatrix}
    1 & 0 \\
    0 & 1
  \end{bmatrix}
\end{equation}

<div class="org-src-container">
<pre class="src src-matlab">g = 2;

Kiff = g/s*tf(eye(2));
</pre>
</div>

<p>
The Root Locus (evolution of the poles of the closed loop system in the complex plane as a function of \(g\)) is shown in Figure <a href="#orgb948acd">7</a>.
It is shown that for non-null rotating speed, one pole is bound to the right-half plane, and thus the closed loop system is unstable.
</p>


<div id="orgb948acd" class="figure">
<p><img src="figs/root_locus_pure_iff.png" alt="root_locus_pure_iff.png" />
</p>
<p><span class="figure-number">Figure 7: </span>Root Locus for the Decentralized Integral Force Feedback controller. Several rotating speed are shown.</p>
</div>
</div>
</div>

<div id="outline-container-orgcdc9bd6" class="outline-3">
<h3 id="orgcdc9bd6"><span class="section-number-3">2.7</span> Sort poles</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1;

Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
       [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
        (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
g = 1;

gains = logspace(-2, 4, 100);

poles = zeros(length(pole(minreal(feedback(Giff, g/s*eye(2))))), length(gains));
poles(:, 1) = pole(minreal(feedback(Giff, gains(1)/s*eye(2))));
poles(:, 2) = pole(minreal(feedback(Giff, gains(2)/s*eye(2))));
% poles(:, 2) = poles(:, 1);

for g_i = 3:length(gains)
    poles_est = poles(:, g_i-1) + (poles(:, g_i-1) - poles(:, g_i-2))*(gains(g_i) - gains(g_i-1))/(gains(g_i-1) - gains(g_i - 2));
    poles_est = poles(:, g_i-1);

    poles_gi = pole(minreal(feedback(Giff, gains(g_i)/s*eye(2))));

    % Array of distances between all the poles
    poles_dist = (poles_est-poles_gi.').*conj(poles_est-poles_gi.');
    [~, c] = sort(min(poles_dist));
    poles_dist = poles_dist(:, c);

    for p_i = 1:size(poles_dist, 1)
       [~, a_i] = min(poles_dist(:, p_i));

       poles(c(p_i), g_i) = poles_gi(a_i);
       poles_dist(a_i, :) = [];
       poles_gi(a_i, :) = [];
    end
end
</pre>
</div>

<p>
Working
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1;

Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
       [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
        (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];

gains = logspace(-2, 4, 500);

poles = zeros(length(pole(feedback(Giff, 1/s*eye(2)))), length(gains));
poles(:, 1) = pole(feedback(Giff, gains(1)/s*eye(2)));
poles(:, 2) = pole(feedback(Giff, gains(2)/s*eye(2)));
% poles(:, 2) = poles(:, 1);

for g_i = 3:length(gains)
    % poles_est = poles(:, g_i-1) + (poles(:, g_i-1) - poles(:, g_i-2))*(gains(g_i) - gains(g_i-1))/(gains(g_i-1) - gains(g_i - 2));
    poles_est = poles(:, g_i-1);
    poles_gi = pole(feedback(Giff, gains(g_i)/s*eye(2)));

    % Array of distances between all the poles
    poles_dist = sqrt((poles_est-poles_gi.').*conj(poles_est-poles_gi.'));

    % Columns of distances are sorted from lowest to highest
    [~, c] = sort(min(poles_dist));
    poles_dist = poles_dist(:, c);

    % for each column of poles_dist corresponding to the i'th pole
    % with closest previous poles
    for p_i = 1:size(poles_dist, 2)
       % Get the indice a_i of the previous pole that is the closest
       % to pole c(p_i)
       [~, a_i] = min(poles_dist(:, p_i));

       poles(a_i, g_i) = poles_gi(c(p_i));

       % poles_dist(a_i, :) = [];
       % poles_gi(a_i, :) = [];
    end
end
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">W = 0.1;

Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
       [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
        (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];

gains = logspace(-2, 4, 500);

poles = zeros(length(pole(feedback(Giff, 1/s*eye(2)))), length(gains));
poles(:, 1) = pole(feedback(Giff, gains(1)/s*eye(2)));
poles(:, 2) = pole(feedback(Giff, gains(2)/s*eye(2)));

for g_i = 3:length(gains)
    % Estimated value of the poles
    poles_est = poles(:, g_i-1) + (poles(:, g_i-1) - poles(:, g_i-2))*(gains(g_i) - gains(g_i-1))/(gains(g_i-1) - gains(g_i - 2));

    % New values for the poles
    poles_gi = pole(feedback(Giff, gains(g_i)/s*eye(2)));

    % Array of distances between all the poles
    poles_dist = sqrt((poles_est-poles_gi.').*conj(poles_est-poles_gi.'));

    % Get indices corresponding to distances from lowest to highest
    [~, c] = sort(min(poles_dist));

    as = 1:length(poles_gi);

    % for each column of poles_dist corresponding to the i'th pole
    % with closest previous poles
    for p_i = c
       % Get the indice a_i of the previous pole that is the closest
       % to pole c(p_i)
       [~, a_i] = min(poles_dist(:, p_i));

       poles(as(a_i), g_i) = poles_gi(p_i);

       % Remove old poles that are already matched
       % poles_gi(as(a_i), :) = [];
       poles_dist(a_i, :) = [];
       as(a_i) = [];
    end
end
</pre>
</div>

<p>
How to remove poles that are not moving?
</p>
<div class="org-src-container">
<pre class="src src-matlab">poles_rl = poles(max(abs(poles(:, 2:end) - poles(:, 1:end-1))') &gt; 1e-8, :);
poles_rl = poles_rl(1:end/2, :);
</pre>
</div>

<ul class="org-ul">
<li>works best without minreal</li>
<li class="off"><code>[&#xa0;]</code> create a function</li>
</ul>

<div class="org-src-container">
<pre class="src src-matlab">Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
       [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
        (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
Kiff = 1/s*eye(2);
gains = logspace(-2, 4, 500);

[poles] = rootLocusPolesSorted(Giff, Kiff, gains, 'd_max', 1e-4);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org18df7e1" class="outline-2">
<h2 id="org18df7e1"><span class="section-number-2">3</span> Modified IFF (pseudo integrator)</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="orgf47e330"></a>
</p>
<ul class="org-ul">
<li>Classical modification of the IFF</li>
</ul>
</div>

<div id="outline-container-orgae8a5d7" class="outline-3">
<h3 id="orgae8a5d7"><span class="section-number-3">3.1</span> Plant Parameters</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>
</div>
</div>

<div id="outline-container-org6abeea4" class="outline-3">
<h3 id="org6abeea4"><span class="section-number-3">3.2</span> Modified Integral Force Feedback Controller</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Let&rsquo;s modify the initial Integral Force Feedback Controller ; instead of using pure integrators, pseudo integrators (i.e. low pass filters) are used:
</p>
\begin{equation}
  K_{\text{IFF}}(s) = g\frac{1}{\omega_i + s} \begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\end{equation}
<p>
where \(\omega_i\) characterize down to which frequency the signal is integrated.
</p>

<p>
Let&rsquo;s arbitrary choose the following control parameters:
</p>
<div class="org-src-container">
<pre class="src src-matlab">g = 2;
wi = 0.1*w0;
</pre>
</div>

<p>
And the following rotating speed.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Giff = 1/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
        [(s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)) + (2*W*s/(w0^2))^2, - (2*xi*s/w0 + 1)*2*W*s/(w0^2) ; ...
         (2*xi*s/w0 + 1)*2*W*s/(w0^2), (s^2/w0^2 - W^2/w0^2)*((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))+ (2*W*s/(w0^2))^2];
</pre>
</div>

<p>
The obtained Loop Gain is shown in Figure <a href="#org6c2de5c">8</a>.
</p>

<div id="org6c2de5c" class="figure">
<p><img src="figs/loop_gain_modified_iff.png" alt="loop_gain_modified_iff.png" />
</p>
<p><span class="figure-number">Figure 8: </span>Loop Gain for the modified IFF controller</p>
</div>
</div>
</div>

<div id="outline-container-org947c64b" class="outline-3">
<h3 id="org947c64b"><span class="section-number-3">3.3</span> Root Locus</h3>
<div class="outline-text-3" id="text-3-3">
<p>
As shown in the Root Locus plot (Figure <a href="#org20a5632">9</a>), for some value of the gain, the system remains stable.
</p>


<div id="org20a5632" class="figure">
<p><img src="figs/root_locus_modified_iff.png" alt="root_locus_modified_iff.png" />
</p>
<p><span class="figure-number">Figure 9: </span>Root Locus for the modified IFF controller</p>
</div>
</div>
</div>

<div id="outline-container-org98a17cf" class="outline-3">
<h3 id="org98a17cf"><span class="section-number-3">3.4</span> What is the optimal \(\omega_i\) and \(g\)?</h3>
<div class="outline-text-3" id="text-3-4">
<p>
In order to visualize the effect of \(\omega_i\) on the attainable damping, the Root Locus is displayed in Figure <a href="#org2470588">10</a> for the following \(\omega_i\):
</p>
<div class="org-src-container">
<pre class="src src-matlab">wis = [0.01, 0.1, 0.5, 1]*w0; % [rad/s]
</pre>
</div>


<div id="org2470588" class="figure">
<p><img src="figs/root_locus_wi_modified_iff.png" alt="root_locus_wi_modified_iff.png" />
</p>
<p><span class="figure-number">Figure 10: </span>Root Locus for the modified IFF controller (zoomed plot on the left)</p>
</div>

<p>
For the controller
</p>
\begin{equation}
  K_{\text{IFF}}(s) = g\frac{1}{\omega_i + s} \begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\end{equation}
<p>
The gain at which the system becomes unstable is
</p>
\begin{equation}
  g_\text{max} = \omega_i \left( \frac{{\omega_0}^2}{\Omega^2} - 1 \right) \label{eq:iff_gmax}
\end{equation}

<p>
While it seems that small \(\omega_i\) do allow more damping to be added to the system (Figure <a href="#org2470588">10</a>), the control gains may be limited to small values due to \eqref{eq:iff_gmax} thus reducing the attainable damping.
</p>


<p>
There must be an optimum for \(\omega_i\).
To find the optimum, the gain that maximize the simultaneous damping of the mode is identified for a wide range of \(\omega_i\) (Figure <a href="#orgf2fdc59">11</a>).
</p>
<div class="org-src-container">
<pre class="src src-matlab">wis = logspace(-2, 1, 31)*w0; % [rad/s]

opt_zeta = zeros(1, length(wis)); % Optimal simultaneous damping
opt_gain = zeros(1, length(wis)); % Corresponding optimal gain

for wi_i = 1:length(wis)
    wi = wis(wi_i);
    gains = linspace(0, (w0^2/W^2 - 1)*wi, 100);

    for g = gains
        Kiff = (g/(wi+s))*eye(2);

        [w, zeta] = damp(minreal(feedback(Giff, Kiff)));

        if min(zeta) &gt; opt_zeta(wi_i) &amp;&amp; all(zeta &gt; 0)
            opt_zeta(wi_i) = min(zeta);
            opt_gain(wi_i) = g;
        end
    end
end
</pre>
</div>


<div id="orgf2fdc59" class="figure">
<p><img src="figs/mod_iff_damping_wi.png" alt="mod_iff_damping_wi.png" />
</p>
<p><span class="figure-number">Figure 11: </span>Simultaneous attainable damping of the closed loop poles as a function of \(\omega_i\)</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orga94cade" class="outline-2">
<h2 id="orga94cade"><span class="section-number-2">4</span> IFF with a stiffness in parallel with the force sensor</h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org7314486"></a>
</p>
</div>

<div id="outline-container-org540ef74" class="outline-3">
<h3 id="org540ef74"><span class="section-number-3">4.1</span> Equations</h3>
<div class="outline-text-3" id="text-4-1">
<div class="important">
\begin{equation}
\begin{bmatrix} f_u \\ f_v \end{bmatrix} =
\bm{G}_k
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

\begin{equation}
\begin{bmatrix} f_u \\ f_v \end{bmatrix} =
\frac{1}{G_{kp}}
\begin{bmatrix}
   G_{kz} & -G_{kc} \\
   G_{kc} &  G_{kz}
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}
<p>
With:
</p>
\begin{align}
  G_{kp} &= \left( \frac{s^2}{{\omega_0^\prime}^2} + 2\xi^\prime \frac{s}{{\omega_0^\prime}^2} + 1 - \frac{\Omega}{\omega_0^\prime} \right)^2 + \left( 2 \frac{\Omega}{\omega_0^\prime}\frac{s}{\omega_0^\prime} \right)^2 \\
  G_{kz} &= \left( \frac{s^2}{{\omega_0^\prime}^2} + \frac{k_p}{k + k_p} - \frac{\Omega^2}{{\omega_0^\prime}^2} \right) \left( \frac{s^2}{{\omega_0^\prime}^2} + 2\xi^\prime \frac{s}{{\omega_0^\prime}^2} + 1 - \frac{\Omega}{\omega_0^\prime} \right) + \left( 2 \frac{\Omega}{\omega_0^\prime}\frac{s}{\omega_0^\prime} \right)^2 \\
  G_{kc} &= \left( 2 \xi^\prime \frac{s}{\omega_0^\prime} + \frac{k}{k + k_p} \right) \left( 2 \frac{\Omega}{\omega_0^\prime}\frac{s}{\omega_0^\prime} \right)
\end{align}
<p>
where:
</p>
<ul class="org-ul">
<li>\(\omega_0^\prime = \frac{k + k_p}{m}\)</li>
<li>\(\xi^\prime = \frac{c}{2 \sqrt{(k + k_p) m}}\)</li>
</ul>

</div>

<div class="org-src-container">
<pre class="src src-matlab">Giff_th = 1/( (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 )*[...
                   (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 - (c*s + k)*(m*s^2 + c*s + k + kp - m*W^2), -(c*s + k)*(2*m*s*W);
                   (c*s + k)*(2*m*s*W), (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 - (c*s + k)*(m*s^2 + c*s + k + kp - m*W^2)
                   ];
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">w0p = sqrt((k + kp)/m);
xip = c/(2*sqrt((k+kp)*m));

Giff_th = 1/( (s^2/w0p^2 + 2*xip*s/w0p + 1 - W^2/w0p^2)^2 + (2*(s/w0p)*(W/w0p))^2 )*[...
                   (s^2/w0p^2 + kp/(k + kp) - W^2/w0p^2)*(s^2/w0p^2 + 2*xip*s/w0p + 1 - W^2/w0p^2) + (2*(s/w0p)*(W/w0p))^2, -(2*xip*s/w0p + k/(k + kp))*(2*(s/w0p)*(W/w0p));
                   (2*xip*s/w0p + k/(k + kp))*(2*(s/w0p)*(W/w0p)), (s^2/w0p^2 + kp/(k + kp) - W^2/w0p^2)*(s^2/w0p^2 + 2*xip*s/w0p + 1 - W^2/w0p^2) + (2*(s/w0p)*(W/w0p))^2
                   ];

Giff_th_b = 1/( (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 )*[...
                   (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 - (c*s + k)*(m*s^2 + c*s + k + kp - m*W^2), -(c*s + k)*(2*m*s*W);
                   (c*s + k)*(2*m*s*W), (m*s^2 + c*s + k + kp - m*W^2)^2 + (2*m*s*W)^2 - (c*s + k)*(m*s^2 + c*s + k + kp - m*W^2)
                   ];
</pre>
</div>
</div>
</div>

<div id="outline-container-org108335f" class="outline-3">
<h3 id="org108335f"><span class="section-number-3">4.2</span> Plant Parameters</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>
</div>
</div>

<div id="outline-container-org32f7060" class="outline-3">
<h3 id="org32f7060"><span class="section-number-3">4.3</span> Schematic</h3>
<div class="outline-text-3" id="text-4-3">

<div id="org6fe63c5" class="figure">
<p><img src="figs-tikz/rotating_xy_platform_springs.png" alt="rotating_xy_platform_springs.png" />
</p>
<p><span class="figure-number">Figure 12: </span>Figure caption</p>
</div>
</div>
</div>

<div id="outline-container-orged2bad9" class="outline-3">
<h3 id="orged2bad9"><span class="section-number-3">4.4</span> Physical Explanation</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>Negative stiffness induced by gyroscopic effects</li>
<li>Zeros of the open-loop &lt;=&gt; Poles of the subsystem with the force sensors removes</li>
<li>As the zeros are the poles of the closed loop system for high gains, we want them to be in the left-half plane</li>
<li>Thus we want the zeros to be in the left half plant and thus the system with the force sensors stable</li>
<li>This can be done by adding springs in parallel with the force sensors with a stiffness larger than the virtual negative stiffness added by the gyroscopic effects</li>
</ul>

<p>
The negative stiffness induced by the rotation is:
</p>
\begin{equation}
  k_{n} = - m \Omega^2
\end{equation}

<p>
And thus, the stiffness in parallel should be such that:
</p>
\begin{equation}
  k_{p} > m \Omega^2
\end{equation}
</div>
</div>

<div id="outline-container-org17ff45b" class="outline-3">
<h3 id="org17ff45b"><span class="section-number-3">4.5</span> Effect of the parallel stiffness on the IFF plant</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The rotation speed is set to \(\Omega = 0.1 \omega_0\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1*w0; % [rad/s]
</pre>
</div>

<p>
And the IFF plant (transfer function from \([F_u, F_v]\) to \([f_u, f_v]\)) is identified in three different cases:
</p>
<ul class="org-ul">
<li>without parallel stiffness</li>
<li>with a small parallel stiffness \(k_p < m \Omega^2\)</li>
<li>with a large parallel stiffness \(k_p > m \Omega^2\)</li>
</ul>

<p>
The results are shown in Figure <a href="#org287914f">13</a>.
</p>

<p>
One can see that for \(k_p > m \Omega^2\), the systems shows alternating complex conjugate poles and zeros.
</p>

<div class="org-src-container">
<pre class="src src-matlab">kp = 0;
cp = 0;

Giff = linearize(mdl, io, 0);

%% Input/Output definition
Giff.InputName  = {'Fu', 'Fv'};
Giff.OutputName = {'fu', 'fv'};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">kp = 0.5*m*W^2;
cp = 0;

Giff_s = linearize(mdl, io, 0);

%% Input/Output definition
Giff_s.InputName  = {'Fu', 'Fv'};
Giff_s.OutputName = {'fu', 'fv'};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">kp = 1.5*m*W^2;
cp = 0;

Giff_l = linearize(mdl, io, 0);

%% Input/Output definition
Giff_l.InputName  = {'Fu', 'Fv'};
Giff_l.OutputName = {'fu', 'fv'};
</pre>
</div>


<div id="org287914f" class="figure">
<p><img src="figs/plant_iff_kp.png" alt="plant_iff_kp.png" />
</p>
<p><span class="figure-number">Figure 13: </span>Transfer function from \([F_u, F_v]\) to \([f_u, f_v]\) for \(k_p = 0\), \(k_p < m \Omega^2\) and \(k_p > m \Omega^2\)</p>
</div>
</div>
</div>

<div id="outline-container-orgc2b6bef" class="outline-3">
<h3 id="orgc2b6bef"><span class="section-number-3">4.6</span> IFF when adding a spring in parallel</h3>
<div class="outline-text-3" id="text-4-6">
<p>
In Figure <a href="#orgeee6dae">14</a> is displayed the Root Locus in the three considered cases with
</p>
\begin{equation}
  K_{\text{IFF}} = \frac{g}{s} \begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\end{equation}

<p>
One can see that for \(k_p > m \Omega^2\), the root locus stays in the left half of the complex plane and thus the control system is unconditionally stable.
</p>

<p>
Thus, decentralized IFF controller with pure integrators can be used if:
</p>
\begin{equation}
  k_{p} > m \Omega^2
\end{equation}


<div id="orgeee6dae" class="figure">
<p><img src="figs/root_locus_iff_kp.png" alt="root_locus_iff_kp.png" />
</p>
<p><span class="figure-number">Figure 14: </span>Root Locus</p>
</div>
</div>
</div>

<div id="outline-container-orga5a387a" class="outline-3">
<h3 id="orga5a387a"><span class="section-number-3">4.7</span> Effect of \(k_p\) on the attainable damping</h3>
<div class="outline-text-3" id="text-4-7">
<p>
However, having large values of \(k_p\) may:
</p>
<ul class="org-ul">
<li>decrease the actuator force authority</li>
<li>decrease the attainable damping</li>
</ul>

<p>
To study the second point, Root Locus plots for the following values of \(k_p\) are shown in Figure <a href="#org72a5da1">15</a>.
</p>
<div class="org-src-container">
<pre class="src src-matlab">kps = [1, 5, 10, 50]*m*W^2;
cp = 0.01;
</pre>
</div>

<p>
It is shown that large values of \(k_p\) decreases the attainable damping.
</p>


<div id="org72a5da1" class="figure">
<p><img src="figs/root_locus_iff_kps.png" alt="root_locus_iff_kps.png" />
</p>
<p><span class="figure-number">Figure 15: </span>Root Locus plot</p>
</div>
</div>
</div>

<div id="outline-container-org2d75241" class="outline-3">
<h3 id="org2d75241"><span class="section-number-3">4.8</span> Optimal Gain</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Let&rsquo;s take \(k_p = 5 m \Omega^2\) and find the optimal IFF control gain \(g\) such that maximum damping are added to the poles of the closed loop system.
</p>

<div class="org-src-container">
<pre class="src src-matlab">kp = 5*m*W^2;
cp = 0.01;

Giff = linearize(mdl, io, 0);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">opt_zeta = 0;
opt_gain = 0;

gains = logspace(-2, 4, 100);

for g = gains
    Kiff = (g/s)*eye(2);

    [w, zeta] = damp(minreal(feedback(Giff, Kiff)));

    if min(zeta) &gt; opt_zeta &amp;&amp; all(zeta &gt; 0)
        opt_zeta = min(zeta);
        opt_gain = min(g);
    end
end
</pre>
</div>


<div id="org6c786cf" class="figure">
<p><img src="figs/root_locus_opt_gain_iff_kp.png" alt="root_locus_opt_gain_iff_kp.png" />
</p>
<p><span class="figure-number">Figure 16: </span>Root Locus for \(k_p = 5 m \Omega^2\) and the poles corresponding to the identified optimal gain</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcdcde0b" class="outline-2">
<h2 id="orgcdcde0b"><span class="section-number-2">5</span> Direct Velocity Feedback</h2>
<div class="outline-text-2" id="text-5">
<p>
<a id="org99ddc3d"></a>
</p>
</div>

<div id="outline-container-org720c634" class="outline-3">
<h3 id="org720c634"><span class="section-number-3">5.1</span> Equations</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The sensed relative velocity are equal to:
</p>
<div class="important">
\begin{equation}
\begin{bmatrix} \dot{d}_u \\ \dot{d}_v \end{bmatrix} =
\bm{G}_v
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}

\begin{equation}
\begin{bmatrix} \dot{d}_u \\ \dot{d}_v \end{bmatrix} =
\frac{s}{k} \frac{1}{G_{vp}}
\begin{bmatrix}
   G_{vz} & G_{vc} \\
  -G_{vc} & G_{vz}
\end{bmatrix}
\begin{bmatrix} F_u \\ F_v \end{bmatrix}
\end{equation}
<p>
With:
</p>
\begin{align}
  G_{vp} &= \left( \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \right)^2 + \left( 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0} \right)^2 \\
  G_{vz} &= \frac{s^2}{{\omega_0}^2} + 2 \xi \frac{s}{\omega_0} + 1 - \frac{{\Omega}^2}{{\omega_0}^2} \\
  G_{vc} &= 2 \frac{\Omega}{\omega_0} \frac{s}{\omega_0}
\end{align}

</div>
</div>
</div>

<div id="outline-container-orgf603713" class="outline-3">
<h3 id="orgf603713"><span class="section-number-3">5.2</span> Plant Parameters</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>
</div>
</div>

<div id="outline-container-org8301d5f" class="outline-3">
<h3 id="org8301d5f"><span class="section-number-3">5.3</span> Plant - Bode Plot</h3>
<div class="outline-text-3" id="text-5-3">
<p>
The rotating speed is set to \(\Omega = 0.1 \omega_0\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1*w0;
</pre>
</div>

<p>
And the transfer function from \([F_u, F_v]\) to \([v_u, v_v]\) is identified using the Simscape model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 1, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Gdvf = linearize(mdl, io, 0);

%% Input/Output definition
Gdvf.InputName  = {'Fu', 'Fv'};
Gdvf.OutputName = {'Vu', 'Vv'};
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e4d88f" class="outline-3">
<h3 id="org9e4d88f"><span class="section-number-3">5.4</span> Comparison of the Analytical Model and the Simscape Model</h3>
<div class="outline-text-3" id="text-5-4">
<p>
The same transfer function from \([F_u, F_v]\) to \([v_u, v_v]\) is written down from the analytical model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Gdvf_th = (s/k)/(((s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2))^2 + (2*W*s/(w0^2))^2) * ...
          [(s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2), 2*W*s/(w0^2) ; ...
           -2*W*s/(w0^2), (s^2)/(w0^2) + 2*xi*s/w0 + 1 - (W^2)/(w0^2)];

Gdvf_th.InputName  = {'Fu', 'Fv'};
Gdvf_th.OutputName = {'vu', 'vv'};
</pre>
</div>

<p>
The two are compared in Figure <a href="#org874c82b">5</a> and found to perfectly match.
</p>


<div id="orgdc81796" class="figure">
<p><img src="figs/plant_dvf_comp_simscape_analytical.png" alt="plant_dvf_comp_simscape_analytical.png" />
</p>
<p><span class="figure-number">Figure 17: </span>Comparison of the transfer functions from \([F_u, F_v]\) to \([v_u, v_v]\) between the Simscape model and the analytical one</p>
</div>
</div>
</div>

<div id="outline-container-orga076c03" class="outline-3">
<h3 id="orga076c03"><span class="section-number-3">5.5</span> Root Locus</h3>
<div class="outline-text-3" id="text-5-5">
<p>
The Decentralized Direct Velocity Feedback controller consist of a pure gain on the diagonal:
</p>
\begin{equation}
  K_{\text{DVF}}(s) = g \begin{bmatrix}
  1 & 0 \\
  0 & 1
\end{bmatrix}
\end{equation}

<p>
The corresponding Root Locus plots for the following rotating speeds are shown in Figure <a href="#org716f855">18</a>.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Ws = [0, 0.1, 0.5, 0.8, 1.1]*w0; % Rotating Speeds [rad/s]
</pre>
</div>

<p>
It is shown that for rotating speed \(\Omega < \omega_0\), the closed loop system is unconditionally stable and arbitrary damping can be added to the poles.
</p>
<div class="org-src-container">
<pre class="src src-matlab">gains = logspace(-2, 2, 100);
</pre>
</div>
</div>

<div id="outline-container-orgaeec22e" class="outline-5">
<h5 id="orgaeec22e"><span class="section-number-5">5.5.0.1</span> Root Locus Plots</h5>
<div class="outline-text-5" id="text-5-5-0-1">

<div id="org716f855" class="figure">
<p><img src="figs/root_locus_dvf.png" alt="root_locus_dvf.png" />
</p>
<p><span class="figure-number">Figure 18: </span>Root Locus for the Decentralized Direct Velocity Feedback controller. Several rotating speed are shown.</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org4e87780" class="outline-2">
<h2 id="org4e87780"><span class="section-number-2">6</span> Comparison</h2>
<div class="outline-text-2" id="text-6">
<p>
<a id="org2e13fe1"></a>
</p>
</div>

<div id="outline-container-org6d1e549" class="outline-3">
<h3 id="org6d1e549"><span class="section-number-3">6.1</span> Plant Parameters</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Let&rsquo;s define initial values for the model.
</p>
<div class="org-src-container">
<pre class="src src-matlab">k = 1;    % Actuator Stiffness [N/m]
c = 0.05; % Actuator Damping [N/(m/s)]
m = 1;    % Payload mass [kg]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">xi = c/(2*sqrt(k*m));
w0 = sqrt(k/m); % [rad/s]
</pre>
</div>

<p>
The rotating speed is set to \(\Omega = 0.1 \omega_0\).
</p>
<div class="org-src-container">
<pre class="src src-matlab">W = 0.1*w0;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2d5912" class="outline-3">
<h3 id="orgb2d5912"><span class="section-number-3">6.2</span> Root Locus</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-matlab">wi = 0.1*w0;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Giff = linearize(mdl, io, 0);

%% Input/Output definition
Giff.InputName  = {'Fu', 'Fv'};
Giff.OutputName = {'Fmu', 'Fmv'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">kp = 5*m*W^2;
cp = 0.01;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 2, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Giff_kp = linearize(mdl, io, 0);

%% Input/Output definition
Giff_kp.InputName  = {'Fu', 'Fv'};
Giff_kp.OutputName = {'Fmu', 'Fmv'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/K'], 1, 'openinput');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/G'], 1, 'openoutput'); io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Gdvf = linearize(mdl, io, 0);

%% Input/Output definition
Gdvf.InputName  = {'Fu', 'Fv'};
Gdvf.OutputName = {'Vu', 'Vv'};
</pre>
</div>

<div id="org4c2835b" class="figure">
<p><img src="figs/comp_root_locus.png" alt="comp_root_locus.png" />
</p>
<p><span class="figure-number">Figure 19: </span>Root Locus plot - Comparison of IFF with additional high pass filter, IFF with additional parallel stiffness and DVF</p>
</div>
</div>
</div>

<div id="outline-container-org96ec842" class="outline-3">
<h3 id="org96ec842"><span class="section-number-3">6.3</span> Controllers - Optimal Gains</h3>
<div class="outline-text-3" id="text-6-3">
<p>
In order to compare to three considered Active Damping techniques, gains that yield maximum damping of all the modes are computed for each case.
</p>

<p>
The obtained damping ratio and control are shown below.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">Obtained \(\xi\)</th>
<th scope="col" class="org-right">Control Gain</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Modified IFF</td>
<td class="org-right">0.83</td>
<td class="org-right">2.0</td>
</tr>

<tr>
<td class="org-left">IFF with \(k_p\)</td>
<td class="org-right">0.84</td>
<td class="org-right">2.01</td>
</tr>

<tr>
<td class="org-left">DVF</td>
<td class="org-right">0.85</td>
<td class="org-right">1.67</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org456f89e" class="outline-3">
<h3 id="org456f89e"><span class="section-number-3">6.4</span> Transmissibility</h3>
<div class="outline-text-3" id="text-6-4">
<p>
<a id="orgfd3ae27"></a>
</p>
<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Tol = linearize(mdl, io, 0);

%% Input/Output definition
Tol.InputName  = {'Dwx', 'Dwy'};
Tol.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">Kiff = opt_gain_iff/(wi + s)*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Tiff = linearize(mdl, io, 0);

%% Input/Output definition
Tiff.InputName  = {'Dwx', 'Dwy'};
Tiff.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">kp = 5*m*W^2;
cp = 0.01;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Kiff = opt_gain_kp/s*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Tiff_kp = linearize(mdl, io, 0);

%% Input/Output definition
Tiff_kp.InputName  = {'Dwx', 'Dwy'};
Tiff_kp.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">Kdvf = opt_gain_kp*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/dw'], 1, 'input');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Tdvf = linearize(mdl, io, 0);

%% Input/Output definition
Tdvf.InputName  = {'Dwx', 'Dwy'};
Tdvf.OutputName = {'Dx', 'Dy'};
</pre>
</div>

<div id="orgcb12ee5" class="figure">
<p><img src="figs/comp_transmissibility.png" alt="comp_transmissibility.png" />
</p>
<p><span class="figure-number">Figure 20: </span>Comparison of the transmissibility</p>
</div>
</div>
</div>

<div id="outline-container-org9ae98b1" class="outline-3">
<h3 id="org9ae98b1"><span class="section-number-3">6.5</span> Compliance</h3>
<div class="outline-text-3" id="text-6-5">
<p>
<a id="orgf4bc970"></a>
</p>
<div class="org-src-container">
<pre class="src src-matlab">%% Name of the Simulink File
mdl = 'rotating_frame';

%% Input/Output definition
clear io; io_i = 1;
io(io_i) = linio([mdl, '/fd'], 1, 'input');  io_i = io_i + 1;
io(io_i) = linio([mdl, '/Meas'], 1, 'output');  io_i = io_i + 1;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Col = linearize(mdl, io, 0);

%% Input/Output definition
Col.InputName  = {'Fdx', 'Fdy'};
Col.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">Kiff = opt_gain_iff/(wi + s)*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Ciff = linearize(mdl, io, 0);

%% Input/Output definition
Ciff.InputName  = {'Fdx', 'Fdy'};
Ciff.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">kp = 5*m*W^2;
cp = 0.01;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Kiff = opt_gain_kp/s*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Ciff_kp = linearize(mdl, io, 0);

%% Input/Output definition
Ciff_kp.InputName  = {'Fdx', 'Fdy'};
Ciff_kp.OutputName = {'Dx', 'Dy'};
</pre>
</div>
<div class="org-src-container">
<pre class="src src-matlab">Kdvf = opt_gain_kp*tf(eye(2));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Cdvf = linearize(mdl, io, 0);

%% Input/Output definition
Cdvf.InputName  = {'Fdx', 'Fdy'};
Cdvf.OutputName = {'Dx', 'Dy'};
</pre>
</div>

<div id="org3b04d90" class="figure">
<p><img src="figs/comp_compliance.png" alt="comp_compliance.png" />
</p>
<p><span class="figure-number">Figure 21: </span>Comparison of the obtained Compliance</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd03ac7f" class="outline-2">
<h2 id="orgd03ac7f"><span class="section-number-2">7</span> Notations</h2>
<div class="outline-text-2" id="text-7">
<p>
<a id="orgead2db3"></a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mathematical Notation</th>
<th scope="col" class="org-left">Matlab</th>
<th scope="col" class="org-left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Actuator Stiffness</td>
<td class="org-left">\(k\)</td>
<td class="org-left"><code>k</code></td>
<td class="org-left">N/m</td>
</tr>

<tr>
<td class="org-left">Actuator Damping</td>
<td class="org-left">\(c\)</td>
<td class="org-left"><code>c</code></td>
<td class="org-left">N/(m/s)</td>
</tr>

<tr>
<td class="org-left">Payload Mass</td>
<td class="org-left">\(m\)</td>
<td class="org-left"><code>m</code></td>
<td class="org-left">kg</td>
</tr>

<tr>
<td class="org-left">Damping Ratio</td>
<td class="org-left">\(\xi = \frac{c}{2\sqrt{km}}\)</td>
<td class="org-left"><code>xi</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Actuator Force</td>
<td class="org-left">\(\bm{F}, F_u, F_v\)</td>
<td class="org-left"><code>F</code> <code>Fu</code> <code>Fv</code></td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">Force Sensor signal</td>
<td class="org-left">\(\bm{f}, f_u, f_v\)</td>
<td class="org-left"><code>f</code> <code>fu</code> <code>fv</code></td>
<td class="org-left">N</td>
</tr>

<tr>
<td class="org-left">Relative Displacement</td>
<td class="org-left">\(\bm{d}, d_u, d_v\)</td>
<td class="org-left"><code>d</code> <code>du</code> <code>dv</code></td>
<td class="org-left">m</td>
</tr>

<tr>
<td class="org-left">Relative Velocity</td>
<td class="org-left">\(\bm{v}, v_u, v_v\)</td>
<td class="org-left"><code>v</code> <code>vu</code> <code>vv</code></td>
<td class="org-left">m/s</td>
</tr>

<tr>
<td class="org-left">Resonance freq. when \(\Omega = 0\)</td>
<td class="org-left">\(\omega_0\)</td>
<td class="org-left"><code>w0</code></td>
<td class="org-left">rad/s</td>
</tr>

<tr>
<td class="org-left">Rotation Speed</td>
<td class="org-left">\(\Omega = \dot{\theta}\)</td>
<td class="org-left"><code>W</code></td>
<td class="org-left">rad/s</td>
</tr>

<tr>
<td class="org-left">Low Pass Filter corner frequency</td>
<td class="org-left">\(\omega_i\)</td>
<td class="org-left"><code>wi</code></td>
<td class="org-left">rad/s</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mathematical Notation</th>
<th scope="col" class="org-left">Matlab</th>
<th scope="col" class="org-left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Laplace variable</td>
<td class="org-left">\(s\)</td>
<td class="org-left"><code>s</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Complex number</td>
<td class="org-left">\(j\)</td>
<td class="org-left"><code>j</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Frequency</td>
<td class="org-left">\(\omega\)</td>
<td class="org-left"><code>w</code></td>
<td class="org-left">[rad/s]</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Mathematical Notation</th>
<th scope="col" class="org-left">Matlab</th>
<th scope="col" class="org-left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">IFF Plant</td>
<td class="org-left">\(\bm{G}_\text{IFF}(s) = \frac{\bm{f}}{\bm{F}}\)</td>
<td class="org-left"><code>Giff</code></td>
<td class="org-left">N/N</td>
</tr>

<tr>
<td class="org-left">DVF Plant</td>
<td class="org-left">\(\bm{G}_\text{DVF}(s) = \frac{\bm{v}}{\bm{F}}\)</td>
<td class="org-left"><code>Gdvf</code></td>
<td class="org-left">(m/s)/N</td>
</tr>

<tr>
<td class="org-left">IFF Controller</td>
<td class="org-left">\(\bm{K}_\text{IFF}(s)\)</td>
<td class="org-left"><code>Kiff</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">DVF Controller</td>
<td class="org-left">\(\bm{K}_\text{DVF}(s)\)</td>
<td class="org-left"><code>Kdvf</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdc36b6b" class="outline-2">
<h2 id="orgdc36b6b"><span class="section-number-2">8</span> Function</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org1b97ee6" class="outline-3">
<h3 id="org1b97ee6"><span class="section-number-3">8.1</span> Sort Poles for the Root Locus</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<a id="orgade3073"></a>
</p>

<p>
This Matlab function is accessible <a href="src/rootLocusPolesSorted.m">here</a>.
</p>
</div>

<div id="outline-container-orgd432ea5" class="outline-4">
<h4 id="orgd432ea5">Function description</h4>
<div class="outline-text-4" id="text-orgd432ea5">
<div class="org-src-container">
<pre class="src src-matlab">function [poles] = rootLocusPolesSorted(G, K, gains, args)
% rootLocusPolesSorted -
%
% Syntax: [poles] = rootLocusPolesSorted(G, K, gains, args)
%
% Inputs:
%    - G, K, gains, args -
%
% Outputs:
%    - poles -
</pre>
</div>
</div>
</div>

<div id="outline-container-org81644c0" class="outline-4">
<h4 id="org81644c0">Optional Parameters</h4>
<div class="outline-text-4" id="text-org81644c0">
<div class="org-src-container">
<pre class="src src-matlab">arguments
    G
    K
    gains
    args.minreal double {mustBeNumericOrLogical} = false
    args.p_half  double {mustBeNumericOrLogical} = false
    args.d_max   double {mustBeNumeric} = -1
end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf223cdb" class="outline-4">
<h4 id="orgf223cdb">Function</h4>
<div class="outline-text-4" id="text-orgf223cdb">
<div class="org-src-container">
<pre class="src src-matlab">if args.minreal
    p1 = pole(minreal(feedback(G, gains(1)*K)));
    [~, i_uniq] = uniquetol([real(p1), imag(p1)], 1e-10, 'ByRows', true);
    p1 = p1(i_uniq);

    poles = zeros(length(p1), length(gains));
    poles(:, 1) = p1;
else
    p1 = pole(feedback(G, gains(1)*K));
    [~, i_uniq] = uniquetol([real(p1), imag(p1)], 1e-10, 'ByRows', true);
    p1 = p1(i_uniq);

    poles = zeros(length(p1), length(gains));
    poles(:, 1) = p1;
end
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">if args.minreal
    p2 = pole(minreal(feedback(G, gains(2)*K)));
    [~, i_uniq] = uniquetol([real(p2), imag(p2)], 1e-10, 'ByRows', true);
    p2 = p2(i_uniq);
    poles(:, 2) = p2;
else
    p2 = pole(feedback(G, gains(2)*K));
    [~, i_uniq] = uniquetol([real(p2), imag(p2)], 1e-10, 'ByRows', true);
    p2 = p2(i_uniq);
    poles(:, 2) = p2;
end
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">for g_i = 3:length(gains)
    % Estimated value of the poles
    poles_est = poles(:, g_i-1) + (poles(:, g_i-1) - poles(:, g_i-2))*(gains(g_i) - gains(g_i-1))/(gains(g_i-1) - gains(g_i - 2));

    % New values for the poles
    poles_gi = pole(feedback(G, gains(g_i)*K));
    [~, i_uniq] = uniquetol([real(poles_gi), imag(poles_gi)], 1e-10, 'ByRows', true);
    poles_gi = poles_gi(i_uniq);

    % Array of distances between all the poles
    poles_dist = sqrt((poles_est-poles_gi.').*conj(poles_est-poles_gi.'));

    % Get indices corresponding to distances from lowest to highest
    [~, c] = sort(min(poles_dist));

    as = 1:length(poles_gi);

    % for each column of poles_dist corresponding to the i'th pole
    % with closest previous poles
    for p_i = c
        % Get the indice a_i of the previous pole that is the closest
        % to pole c(p_i)
        [~, a_i] = min(poles_dist(:, p_i));

        poles(as(a_i), g_i) = poles_gi(p_i);

        % Remove old poles that are already matched
        % poles_gi(as(a_i), :) = [];
        poles_dist(a_i, :) = [];
        as(a_i) = [];
    end
end
</pre>
</div>
</div>
</div>

<div id="outline-container-orga51595e" class="outline-4">
<h4 id="orga51595e">Remove useless poles</h4>
<div class="outline-text-4" id="text-orga51595e">
<div class="org-src-container">
<pre class="src src-matlab">if args.d_max &gt; 0
    poles = poles(max(abs(poles(:, 2:end) - poles(:, 1:end-1))') &gt; args.d_max, :);
end

if args.p_half
    poles = poles(1:round(end/2), :);
end
</pre>
</div>
</div>
</div>

<div id="outline-container-org496fb30" class="outline-4">
<h4 id="org496fb30">Sort poles</h4>
<div class="outline-text-4" id="text-org496fb30">
<div class="org-src-container">
<pre class="src src-matlab">[~, s_p] = sort(imag(poles(:,1)), 'descend');
poles = poles(s_p, :);
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Thomas Dehaeze</p>
<p class="date">Created: 2020-06-18 jeu. 11:51</p>
</div>
</body>
</html>
